"""
This module provides visualizers to draw Hasse diagrams

WARNING: The module is in production. It has not been fully tested and designed yet.
"""
from fcapy.poset import POSet
from fcapy.visualizer.hasse_layouts import LAYOUTS
from fcapy.utils.utils import get_kwargs_used, get_not_none
from fcapy.lattice import ConceptLattice

from typing import Tuple, Callable, Dict
from pydantic import BaseModel


class AbstractHasseViz(BaseModel):
    """An abstract class for Hasse visualizer that keeps all the possible visualization parameters"""

    #####################
    # Fields            #
    #####################
    pos: Dict[int, Tuple[float, float]] = None

    # Node fields
    nodelist: Tuple[int] = None
    node_color: str = 'lightgray'

    node_alpha: float = 1
    node_size: float = 300
    node_label_func: Callable[[int, POSet], str] = None
    node_label_font_size: int = 12
    node_border_color: str = 'white'
    node_border_width: float = 1

    # Edge fields
    edgelist: Tuple[int, int] = None
    edge_color: str = 'lightgray'
    edge_radius: float = 0

    # Colormap fields
    cmap: str = 'Blues'
    cmap_min: float = None
    cmap_max: float = None

    # Binary toggles
    flg_node_indices: bool = False
    flg_axes: bool = False

    #####################
    # Functions         #
    #####################

    # Drawing functions
    def draw_poset(self, poset: POSet, **kwargs):
        raise NotImplementedError

    def draw_quiver(self, poset: POSet, edges: Tuple[int, int, str], **kwargs):
        """Quiver = directed graph with multiple edges between pairs of nodes. WARNING: It's the test feature"""
        raise NotImplementedError

    def draw_concept_lattice(self, lattice: ConceptLattice, **kwargs):
        """Draw `lattice` with `draw_poset` function with node labels generated by `concept_lattice_label_func`"""
        if 'node_label_func' not in kwargs:
            kwargs_used = get_kwargs_used(kwargs, self.concept_lattice_label_func)
            kwargs['node_label_func'] = lambda c_i, L: self.concept_lattice_label_func(c_i, L, **kwargs_used)
        self.draw_poset(lattice, **kwargs)

    # Other useful functions
    @staticmethod
    def get_nodes_position(poset: POSet, layout='fcart', **kwargs):
        """Return a dict of nodes positions in a line diagram"""
        if layout not in LAYOUTS:
            raise ValueError(
                f'Layout "{layout}" is not supported. '
                f'Possible layouts are: {", ".join(LAYOUTS.keys())}'
            )
        layout_func = LAYOUTS[layout]
        kwargs_used = get_kwargs_used(kwargs, layout_func)
        return layout_func(poset, **kwargs_used)

    def _filter_nodes_edges(self, G, nodelist=None, edgelist=None):
        # set up default values if none specified
        nodelist = get_not_none(nodelist, self.nodelist)
        edgelist = get_not_none(edgelist, self.edgelist)

        # draw all nodes if none is still specified
        if nodelist is None:
            nodelist = list(G.nodes)

        # draw only the edges for the drawn nodes. If other is not specified
        if edgelist is None:
            edgelist = list(G.edges)
        edgelist = [e for e in edgelist if all([v in nodelist for v in e[:2]])]

        return nodelist, edgelist

    @staticmethod
    def concept_lattice_label_func(
            c_i: int, lattice: ConceptLattice,
            flg_new_intent_count_prefix: bool = True, max_new_intent_count: int = 2,
            flg_new_extent_count_prefix: bool = True, max_new_extent_count: int = 2
    ) -> str:
        def short_set_repr(set_: set, flg_count_prefix: bool, max_count: int) -> str:
            if len(set_) > 0:
                s = f"{len(set_)}: " if flg_count_prefix else ""
                s += ', '.join(sorted(set_)[:max_count])
            else:
                s = ''
            return s

        new_intent_str = short_set_repr(lattice.get_concept_new_intent(c_i),
                                        flg_new_intent_count_prefix, max_new_intent_count)
        new_extent_str = short_set_repr(lattice.get_concept_new_extent(c_i),
                                        flg_new_extent_count_prefix, max_new_extent_count)

        label = '\n\n'.join([new_intent_str, new_extent_str])
        return label


class NetworkxHasseViz(AbstractHasseViz):
    f"""A class to draw Hasse visualisations via Networkx package"""

    def draw_poset(self, poset: POSet, ax=None, **kwargs):
        """Draw a Partially Ordered Set as Hasse diagram with Networkx package

        WARNING: Please specify `ax` parameter in order for the function to work properly
        e.g.
        ```
        import matplotlib.pyplot as plt
        viz = NetworkxHasseViz()
        poset = POSet(...)

        fig, ax = plt.subplots()
        viz.draw_poset(poset, ax=ax, ...)
        ```
        """
        assert ax is not None,\
            "Please specify `ax` parameter in order for the function to work properly." \
            "You may obtain the `ax` value via ```import matplotlib.pyplot as plt; fig, ax = plt.subplots()```"

        pos_defined = kwargs.get('pos', self.pos)
        pos = self.get_nodes_position(poset) if pos_defined is None else pos_defined
        if 'pos' in kwargs:
            del kwargs['pos']

        G = poset.to_networkx('down')
        kwargs_used = get_kwargs_used(kwargs, self._filter_nodes_edges)
        nodelist, edgelist = self._filter_nodes_edges(G, **kwargs_used)
        for k in ['nodelist', 'edgelist']:
            if k in kwargs:
                del kwargs[k]

        kwargs_used = get_kwargs_used(kwargs, self._draw_edges)
        self._draw_edges(G, pos, ax, edgelist, **kwargs_used)

        kwargs_used = get_kwargs_used(kwargs, self._draw_nodes)
        self._draw_nodes(G, pos, ax, nodelist, **kwargs_used)

        node_label_func = kwargs.get('node_label_func', self.node_label_func)
        if node_label_func is not None:
            kwargs_used = get_kwargs_used(kwargs, self._draw_node_labels)
            self._draw_node_labels(poset, G, pos, ax, nodelist, **kwargs_used)

        flg_node_indices = kwargs.get('flg_node_indices', self.flg_node_indices)
        if flg_node_indices:
            self._draw_node_indices(G, pos, ax, nodelist)

        flg_axes = kwargs.get('flg_axes', self.flg_axes)
        if flg_axes:
            ax.set_axis_on()
        else:
            ax.set_axis_off()

        return G, pos, nodelist, edgelist

    def draw_concept_lattice(self, lattice: ConceptLattice, **kwargs):
        """Draw `lattice` with `draw_poset` function with node labels generated by `concept_lattice_label_func`

        WARNING: Please specify the `ax` parameter from kwargs in order for the function to work properly
        e.g.
        ```
        import matplotlib.pyplot as plt
        viz = NetworkxHasseViz()
        L = ConceptLattice(...)

        fig, ax = plt.subplots()
        viz.draw_concept_lattice(L, ax=ax, ...)
        ```
        """
        super(NetworkxHasseViz, self).draw_concept_lattice(lattice, **kwargs)

    def draw_quiver(self, poset: POSet, edges: Tuple[int, int, str], ax=None, **kwargs):
        """Quiver = directed graph with multiple edges between pairs of nodes. WARNING: It's the test feature"""
        G, pos, nodelist, _ = self.draw_poset(poset, ax, **dict(kwargs, edgelist=[]))

        edge_label_rotate = kwargs.get('edge_label_rotate', False)
        edge_label_pos = kwargs.get('edge_label_pos', 0.9)
        edge_color = kwargs.get('edge_color', self.edge_color)

        is_edge_color_rgba_single = len(edge_color) in {3, 4} and all([isinstance(x, float) for x in edge_color])
        is_edge_color_specific = len(edge_color) == len(edges) and not is_edge_color_rgba_single

        edge_labels_map = {}
        for e in edges:
            child_i, parent_i, label = e
            edge_labels_map[(parent_i, child_i)] = edge_labels_map.get((parent_i, child_i), []) + [label]

        edgelist = list(edge_labels_map)

        multiedges = list(set([el for i, el in enumerate(edgelist) if el in edgelist[i + 1:]]))

        for edge, labels in edge_labels_map.items():
            if len(labels) % 2 == 0:
                r_func = lambda i: (i // 2 + 1) * ((-1) ** (i % 2))
            else:
                r_func = lambda i: ((i - 1) // 2 + 1) * ((-1) ** (i % 2 + 1))

            for i, label in enumerate(labels):
                if is_edge_color_specific:
                    edge_lbl = (edge[1], edge[0], label)
                    edge_lbl_i = edges.index(edge_lbl)
                    edge_color_ = edge_color[edge_lbl_i]
                else:
                    edge_color_ = edge_color

                r = r_func(i)
                self._draw_edges(G, pos, ax, [edge], edge_radius=r*0.1, edge_color=[edge_color_])

        import networkx as nx
        nx.draw_networkx_edge_labels(
            G, pos,
            edge_labels={edge: '\n'.join(labels) for edge, labels in edge_labels_map.items()},
            rotate=edge_label_rotate,
            ax=ax, label_pos=edge_label_pos
        )
        return G, pos, nodelist, edgelist

    def _draw_nodes(
            self, G, pos, ax, nodelist,
            node_color=None, cmap=None, node_alpha=None,
            node_border_width=None, node_border_color=None,
            cmap_min=None, cmap_max=None, node_size=None
    ):
        node_color = get_not_none(node_color, self.node_color)
        cmap = get_not_none(cmap, self.cmap)
        node_alpha = get_not_none(node_alpha, self.node_alpha)
        node_border_width = get_not_none(node_border_width, self.node_border_width)
        node_border_color = get_not_none(node_border_color, self.node_border_color)
        cmap_min = get_not_none(cmap_min, self.cmap_min)
        cmap_max = get_not_none(cmap_max, self.cmap_max)
        node_size = get_not_none(node_size, self.node_size)

        import networkx as nx

        nx.draw_networkx_nodes(
            G, pos,
            nodelist=nodelist,
            node_color=node_color, cmap=cmap, alpha=node_alpha,
            linewidths=node_border_width, edgecolors=node_border_color,
            vmin=cmap_min, vmax=cmap_max,
            ax=ax,
            node_size=node_size
        )

    def _draw_node_labels(
            self, poset, G, pos, ax, nodelist,
            node_label_func=None, node_label_font_size=None
    ):
        node_label_func = get_not_none(node_label_func, self.node_label_func)
        node_label_font_size = int(get_not_none(node_label_font_size, self.node_label_font_size))

        import networkx as nx

        labels = {el_i: node_label_func(el_i, poset) for el_i in nodelist}
        nx.draw_networkx_labels(
            G, pos,
            labels=labels,
            horizontalalignment='center',  # 'left',
            font_size=node_label_font_size,
            ax=ax
        )

    def _draw_node_indices(self, G, pos, ax, nodelist):
        import networkx as nx

        labels = {el_i: f"{el_i}" for el_i in nodelist}
        nx.draw_networkx_labels(G, pos, ax=ax, labels=labels)

    def _draw_edges(
            self, G, pos, ax, edgelist,
            edge_radius=None, edge_color=None
    ):
        edge_radius = get_not_none(edge_radius, self.edge_radius)
        edge_color = get_not_none(edge_color, self.edge_color)

        import networkx as nx

        cs = f'arc3,rad={edge_radius}' if edge_radius is not None else None
        nx.draw_networkx_edges(
            G, pos,
            edgelist=edgelist,
            edge_color=edge_color,
            arrowstyle='-', connectionstyle=cs,
            ax=ax
        )
